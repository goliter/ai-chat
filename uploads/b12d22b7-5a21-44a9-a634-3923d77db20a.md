# 工程化篇

## ES6 模块与 CommonJS 模块的区别

### 为什么不在浏览器使用 CommonJS

在讨论这个问题之前，我们需要认识到，CommonJS 的 `require` 语法是同步的。即在使用 `require` 加载模块时，必须等待该模块加载完成后，才能继续执行后面的代码。这个特点对于 Node.js（服务端）是可行的，因为大多数模块都是从本地硬盘读取，速度较快。

而在浏览器端，模块一般存储在服务器或 CDN 上，使用同步加载将依赖网络速度，可能导致长时间的等待，这样会使得浏览器出现“假死状态”。因此，AMD 和 CMD 这类模块化方案应运而生，它们都采用异步加载，比较适合在浏览器环境中使用。

### 差异区别

CommonJS 和 ES6 模块之间的主要差异有两个：

1. CommonJS 模块输出的是值的拷贝，而 ES6 模块输出的是值的引用。
2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

#### 第一个差异：值的拷贝 vs 值的引用

**CommonJS 输出值的拷贝**：

当一个模块输出某个值后，模块内部的后续变化不会影响外部对这个值的使用。

```javascript

// lib.js

varcounter=3;

functionincCounter() {

counter++;

}

module.exports= {

counter: counter,

incCounter: incCounter,

};


// 使用模块

varmod=require("./lib");

console.log(mod.counter); // 3

mod.incCounter();

console.log(mod.counter); // 3

```

**ES6 模块输出值的引用**：

ES6 模块的 import 变量是只读引用，这意味着变量的值会反映出模块内部的变化。

```javascript

// lib.js

exportletcounter=3;

exportfunctionincCounter() {

counter++;

}


// main.js

import { counter, incCounter } from"./lib";

console.log(counter); // 3

incCounter();

console.log(counter); // 4

```

#### 第二个差异：运行时加载 vs 编译时输出接口

CommonJS 模块在运行时生成 object，并缓存后续的调用。而 ES6 模块在编译期间就生成了静态接口，使得可以进行依赖分析，提升了代码优化能力。

### 循环加载（Circular Dependency）

#### CommonJS 的循环加载

CommonJS 遇到循环加载时，只输出当前已执行部分，而未执行的部分不会输出。

```javascript

// a.js

exports.done=false;

varb=require("./b.js");

console.log("在 a.js 之中，b.done = %j", b.done);

exports.done=true;


// b.js

exports.done=false;

vara=require("./a.js");

console.log("在 b.js 之中，a.done = %j", a.done);

exports.done=true;


// main.js

vara=require("./a.js");

varb=require("./b.js");

console.log("在 main.js 之中, a.done=%j, b.done=%j", a.done, b.done);

```

执行结果为：

```

在 b.js 之中，a.done = false

b.js 执行完毕

在 a.js 之中，b.done = true

a.js 执行完毕

在 main.js 之中, a.done=true, b.done=true

```

#### ES6 的循环加载

ES6 模块是动态引用，import 变量不会被缓存，是真正取值时获取最终值。

```javascript

// even.js

import { odd } from"./odd";

exportvarcounter=0;

exportfunctioneven(n) {

counter++;

returnn===0||odd(n-1);

}


// odd.js

import { even } from"./even";

exportfunctionodd(n) {

returnn!==0&&even(n-1);

}

```

执行这段代码，可以观察到 counter 的值会随着模块内部变化而变化。

### 其他差异

1.**顶层 `this` 的指向**：

- CommonJS 顶层的 `this` 指向当前模块。
- ES6 模块顶层的 `this` 指向 `undefined`。

2.**互相引用的支持**：

- ES6 模块可以直接加载 CommonJS 模块，但只能整体加载。
- CommonJS 无法 require ES6 模块。

### 总结

| 特性             | CommonJS                                   | ES6 Module                                           |

| ---------------- | ------------------------------------------ | ---------------------------------------------------- | ---- |

| -                | 加载方式                                   | 同步                                                 | 异步 |

| 适用场景         | 主要用于服务端                             | 可用于浏览器和服务端                                 |

| 导出方式         | 输出值的拷贝                               | 输出值的引用                                         |

| 加载时机         | 运行时加载                                 | 编译时输出接口                                       |

| 循环依赖处理     | 只输出已执行部分，后续变化不影响已输出变量 | 实时取值，获取最新值                                 |

| 顶层 `this` 指向 | 指向当前模块                               | 指向 `undefined`                                     |

| 互相引用的支持   | CommonJS 无法 require ES6 模块             | ES6 模块可以直接加载 CommonJS 模块，但只能整体加载。 |

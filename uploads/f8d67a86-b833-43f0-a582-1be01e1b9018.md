# PROBLEM：废墟图书馆：

Time Limit:1000 ms

Memory Limit:65535k

## Description

罗兰和阿尔加利亚二人都是都市中数一数二的顶级收尾人。出于某些原因，他们两人都将对方视为宿敌。就在今天，他们在后巷中相遇了，于是他们当即起意要来一场酣畅淋漓的对决。由于他们的对决过于复杂，所以我们以一种相对简单的方式来模拟他们对决的过程，具体如下：



我们用生命值和混乱值来表示他们的状态；初始时二人生命值和混乱值都是上限。



他们的对决会以投骰子的方式进行，骰子有三种类别，分别是攻击骰子（id=0），防御骰子(id=1)，闪避骰子(id=2)，每个骰子都会有一个具体数值（为了简化问题）来代表该骰子点数的大小。战斗开始时，他们二人会拥有相同数量的骰子，每个回合开始时，他们会同时按顺序使用骰子，此时根据骰子种类和点数不同，会有如下拼点情况：

* 当两个攻击骰子进行拼点时：点数大的一方对点数小的一方造成数值等于该点数的伤害和混乱伤害（分别对应生命值的减少和混乱值的减少），然后结束回合。如若点数相同则直接结束该回合。
* 当攻击骰子对防御骰子进行拼点时：若攻击骰子点数更大，则对防守方造成数值等于（攻击点数 - 防御点数）的伤害和混乱伤害；若防御骰子点数更大，则对攻击方造成数值等于（防御点数 - 攻击点数）的混乱伤害。然后结束回合。如若点数相同则直接跳过该回合。
* 当两个防御骰子进行拼点时：点数大的一方对点数小的一方造成数值等于（两防御骰子点数的差的绝对值）的混乱伤害，然后结束回合。如若点数相同则直接结束回合。
* 当攻击骰子对闪避骰子进行拼点时：若攻击骰子点数更大，则对闪避方造成数值等于（攻击点数 ）的伤害和混乱伤害，然后结束回合；若闪避骰子点数更大或相等则直接结束回合。
* 当防御骰子对闪避骰子进行拼点时：若防御骰子点数更大，则对闪避方造成数值等于（防御点数 ）的混乱伤害，然后结束回合；若闪避骰子点数更大或相等则直接结束回合。
* 当两个闪避骰子进行拼点时：不管点数多少都直接结束回合。


当一方生命值减少到0及以下时或二人骰子全部用完时，对决直接结束。

当一方混乱值减少到0及以下时，则下个回合该方的骰子直接变成点数为0的闪避骰子并且混乱值立即回复到上限(若没有剩余骰子就只会回复混乱值)。



请输出对决结束时两人的状态（第一行罗兰，第二行阿尔加利亚），若存活则输出剩下的生命值和混乱值，若死亡则输出DEAD。



## Input

第1行输入二人共同的的生命值（life）和混乱值上限(sans)。

第2行输入二人各自的骰子数量n。

3~3+n行每行输入骰子的id和数值ai,这些是罗兰的所有骰子。

n+4~2n+4行每行输入骰子的id和数值bi,这些是阿尔加利亚的所有骰子。

保证id只会是0或1或2，1<=n<=1e5，1<=life<=1e5 , 1<=sans<=1e5，1<=ai<=1e5。

## Output

第一行输出罗兰的状态,若存活则输出剩下的生命值和混乱值，若死亡则输出DEAD。

第二行输出阿尔加利亚的状态,若存活则输出剩下的生命值和混乱值，若死亡则输出DEAD。





## Sample Input

10 10

5

0 5

0 4

0 3

1 20

0 5

0 3

1 3

2 5

1 8

0 100



## Sample Output

10 10

DEAD



## Hint

第一回合，罗兰的攻击骰子点数（5）大于阿尔加利亚的攻击骰子点数（3），对阿尔加利亚造成5点伤害和5点混乱伤害。

二人状态：罗兰：10 10；阿尔加利亚：5 5；



第二回合，罗兰的攻击骰子点数（4）大于阿尔加利亚的防御骰子点数（3），对阿尔加利亚造成（4-3）点伤害和（4-3）点混乱伤害。

二人状态：罗兰：10 10；阿尔加利亚：4 4；



第三回合，罗兰的攻击骰子点数（3）小于阿尔加利亚的闪避骰子点数（5），回合直接结束。

二人状态：罗兰：10 10；阿尔加利亚：4 4；



第四回合，罗兰的防御骰子点数（20）大于阿尔加利亚的闪避骰子点数（8），对阿尔加利亚造成（20）点混乱伤害，阿尔加利亚混乱值变为-16，小于等于0，所以下一个骰子变为点数为0的闪避骰子，并将将自己的混乱值回复到上限10.

二人状态：罗兰：10 10；阿尔加利亚：4 10；



第五回合，罗兰的攻击骰子点数（5）大于阿尔加利亚的闪避骰子点数（0），对阿尔加利亚造成5点伤害和5点混乱伤害，阿尔加利亚生命值变为-1，小于0，死亡。对决结束

二人状态：罗兰：10 10；阿尔加利亚：-1 5；



最终输出罗兰：10 10；阿尔加利亚：DEAD；



## Source

goliter



## 数据：

### 样例：

#### 输入：

```
10 10
5
0 5
0 4
0 3
1 20
0 5
0 3
1 3
2 5
1 8
0 100
```



#### 输出：

```
10 10
DEAD
```



### 测试用例 1：基础对决

#### 输入：

```
复制代码
10 10
3
0 5
0 6
1 8
0 4
1 3
2 7
```

#### 预期输出：

```
复制代码
10 10
2 10
```

------

### 测试用例 2：混乱状态触发

#### 输入：

```
复制代码
20 10
5
1 15
0 10
0 5
1 3
0 7
1 5
1 20
0 4
2 6
0 9
```

#### 预期输出：

```
复制代码
11 1
5 5
```

------

### 测试用例 3：所有骰子用完

#### 输入：

```
复制代码
50 50
3
0 20
1 15
2 30
1 10
0 25
2 35
```

#### 预期输出：

```
复制代码
50 50
40 40
```

------

### 测试用例 4：罗兰快速击杀阿尔加利亚

#### 输入：

```
复制代码
30 15
4
0 15
0 10
0 5
1 7
2 3
1 4
1 6
0 25
```

#### 预期输出：

```
复制代码
30 14
5 5
```

------

### 测试用例 5：混乱状态多次触发

#### 输入：

```
复制代码
50 10
6
1 12
1 8
1 5
0 6
1 7
0 10
2 3
0 20
1 4
1 8
2 10
0 5
```

#### 预期输出：

```
复制代码
50 8
40 10
```







# 代码：

```
#include <iostream>
#include <vector>
using namespace std;

struct Dice {
    int id, value;
};

int main() {
    // 输入生命值和混乱值上限
    int life, sans;
    cin >> life >> sans;

    // 输入骰子数量
    int n;
    cin >> n;

    // 读取罗兰和阿尔加利亚的骰子
    vector<Dice> roland(n), algalia(n);
    for (int i = 0; i < n; i++) {
        cin >> roland[i].id >> roland[i].value;
    }
    for (int i = 0; i < n; i++) {
        cin >> algalia[i].id >> algalia[i].value;
    }

    // 初始化生命值和混乱值
    int r_life = life, r_sans = sans;
    int a_life = life, a_sans = sans;

    // 标记是否进入混乱状态
    bool r_confused = false, a_confused = false;

    // 模拟战斗过程
    for (int i = 0; i < n; i++) {
        // 当前骰子
        Dice r_dice = roland[i];
        Dice a_dice = algalia[i];

        // 若进入混乱状态，上回合骰子变形为闪避骰子
        if (r_confused) {
            r_dice.id = 2;
            r_dice.value = 0;
            r_confused = false; // 重置标志位
        }
        if (a_confused) {
            a_dice.id = 2;
            a_dice.value = 0;
            a_confused = false; // 重置标志位
        }

        // 根据骰子类型和点数拼点
        if (r_dice.id == 0 && a_dice.id == 0) { // 攻击 vs 攻击
            if (r_dice.value > a_dice.value) {
                a_life -= r_dice.value;
                a_sans -= r_dice.value;
            } else if (r_dice.value < a_dice.value) {
                r_life -= a_dice.value;
                r_sans -= a_dice.value;
            }
        } else if (r_dice.id == 0 && a_dice.id == 1) { // 攻击 vs 防御
            if (r_dice.value > a_dice.value) {
                a_life -= (r_dice.value - a_dice.value);
                a_sans -= (r_dice.value - a_dice.value);
            } else if (r_dice.value < a_dice.value) {
                r_sans -= (a_dice.value - r_dice.value);
            }
        } else if (r_dice.id == 1 && a_dice.id == 1) { // 防御 vs 防御
            if (r_dice.value != a_dice.value) {
                int diff = abs(r_dice.value - a_dice.value);
                if (r_dice.value > a_dice.value) {
                    a_sans -= diff;
                } else {
                    r_sans -= diff;
                }
            }
        } else if (r_dice.id == 0 && a_dice.id == 2) { // 攻击 vs 闪避
            if (r_dice.value > a_dice.value) {
                a_life -= r_dice.value;
                a_sans -= r_dice.value;
            }
        } else if (r_dice.id == 1 && a_dice.id == 2) { // 防御 vs 闪避
            if (r_dice.value > a_dice.value) {
                a_sans -= r_dice.value;
            }
        }
        //cout<<r_life<<" "<<r_sans<<endl;
        //cout<<a_life<<" "<<a_sans<<endl;
        // 检查混乱值
        if (r_sans <= 0) {
            r_sans = sans; // 立即回复混乱值
            r_confused = true; // 下一回合骰子变形
        }
        if (a_sans <= 0) {
            a_sans = sans; // 立即回复混乱值
            a_confused = true; // 下一回合骰子变形
        }

        // 检查生命值
        if (r_life <= 0 || a_life <= 0) {
            break;
        }
    }

    // 输出结果
    if (r_life <= 0) {
        cout << "DEAD" << endl;
    } else {
        cout << r_life << " " << r_sans << endl;
    }
    if (a_life <= 0) {
        cout << "DEAD" << endl;
    } else {
        cout << a_life << " " << a_sans << endl;
    }

    return 0;
}

```

